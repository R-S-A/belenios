(** Election primitives *)

open Signatures

val finite_field : p:Z.t -> q:Z.t -> g:Z.t ->
  (module GROUP with type t = Z.t)
(** [finite_field p q g] builds the multiplicative subgroup of F[p],
    generated by [g], of order [q]. *)

val check_finite_field : p:Z.t -> q:Z.t -> g:Z.t -> bool
(** Check consistency of finite field parameters. *)

val check_election : (module ELECTION_PARAMS) -> bool
(** Check consistency of election parameters. *)

module MakeSimpleMonad (G : GROUP) : sig

  (** {2 Monadic definitions} *)

  type 'a t = unit -> 'a
  val return : 'a -> 'a t
  val bind : 'a t -> ('a -> 'b t) -> 'b t

  (** {2 Random number generation} *)

  val random : Z.t -> Z.t t
  (** [random q] returns a random number modulo [q]. It uses a secure
      random number generator lazily initialized by a seed shared by all
      instances. *)

  (** {2 Ballot box management} *)

  (** The following implements the {!module:Signatures.BALLOT_BOX} interface. *)

  type ballot = G.t Serializable_t.ballot
  val cast : ballot -> unit t
  val fold : (ballot -> 'a -> 'a t) -> 'a -> 'a t
end
(** Simple election monad that keeps all ballots in memory. *)

module MakeSimpleDistKeyGen (G : GROUP) (M : RANDOM) : sig

  (** This module implements a simple distributed key generation. Each
      share is a number modulo q, and the secret key is their sum. All
      shares are needed to decrypt, but the decryptions can be done in
      a distributed fashion. *)

  val generate_and_prove :
    unit -> (Z.t * G.t Serializable_t.trustee_public_key) M.t
  (** [generate_and_prove ()] returns a new keypair [(x, y)]. [x] is
      the secret exponent, [y] contains the public key and a
      zero-knowledge proof of knowledge. *)

  val check : G.t Serializable_t.trustee_public_key -> bool
  (** Check a public key and its proof. *)

  val combine : G.t Serializable_t.trustee_public_key array -> G.t
  (** Combine all public key shares into an election public key. *)

end
(** Simple distributed generation of an election public key. *)

module MakeElection (P : ELECTION_PARAMS) (M : RANDOM) :
  ELECTION with type elt = P.G.t and type 'a m = 'a M.t
(** Implementation of {!Signatures.ELECTION}. *)
